<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>How does drawing work? | Thraka</title>
  <meta name="author" content="Thraka">
  
  <meta name="description" content="When SadConsole draws a dirty surface, it does not draw it directly to the screen. Each Surface has a LastRenderResult property that represents the la">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="How does drawing work?"/>
  <meta property="og:site_name" content="Thraka"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-76753055-1', 'auto');
  ga('send', 'pageview');
</script>




</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Thraka</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
            
            <a href="/blog" title="All the articles">
            
			  <i class=""></i>Blog
			</a>
		  </li>
		  
		  <li>
            
            <a href="/docs" title="Documentation for SadConsole">
            
			  <i class=""></i>Documentation
			</a>
		  </li>
		  
		  <li>
            
			<a href="https://github.com/thraka/sadconsole" title="SadConsole GitHub">
            
			  <i class="fa fa-github"></i>Github
			</a>
		  </li>
		  
		  <li>
            
			<a href="https://www.reddit.com/r/sadconsole/" title="SadConsole SubReddit">
            
			  <i class="fa fa-reddit"></i>Reddit
			</a>
		  </li>
		  
		  <li>
            
            <a href="/atom.xml" title="Subscribe">
            
			  <i class="fa fa-rss"></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 
	
		<div class="page-header">
			<h1> How does drawing work?</h1>
		</div>
	



<div class="row page">
	<!-- cols -->
	
	<div class="col-md-12">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>When SadConsole draws a dirty surface, it does not draw it directly to the screen. Each Surface has a <a href="https://github.com/Thraka/SadConsole/blob/master/src/SadConsole.Shared/Surfaces/BasicSurface.cs" target="_blank" rel="noopener"><code>LastRenderResult</code></a> property that represents the last drawn state of the surface. All of these surfaces are gathered together and drawn on a final texture, <a href="https://github.com/Thraka/SadConsole/blob/master/src/SadConsole.Shared/Global.cs" target="_blank" rel="noopener"><code>Global.RenderOutput</code></a>. This texture is then drawn to the screen.</p>
<h2 id="Cached-textures"><a href="#Cached-textures" class="headerlink" title="Cached textures"></a>Cached textures</h2><p>As stated above, each surface creates a texture that represents the final look of the console-surface. A <a href="https://github.com/Thraka/SadConsole/blob/master/src/SadConsole.Shared/Renderers/ISurfaceRenderer.cs" target="_blank" rel="noopener"><code>SadConsole.Renderers.ISurfaceRenderer</code></a> object is responsible for this. When the renderer processes a surface, it first checks if the <a href="https://github.com/Thraka/SadConsole/blob/master/src/SadConsole.Shared/Surfaces/BasicSurface.cs" target="_blank" rel="noopener"><code>IsDirty</code></a> property is set to <code>true</code>. If so, it updates the cached texture with the latest state of the surface.</p>
<p>This is efficient because there is less to render to the screen each frame. A 100x100 console has about 20,000 sprite-draws each frame. If a surface doesn’t change very often, this is a lot of wasted time for your GPU. By caching each draw to a texture, a single draw call is required each frame instead of all 20,000 individual draws.</p>
<h2 id="Final-draw"><a href="#Final-draw" class="headerlink" title="Final draw"></a>Final draw</h2><p>Now that we know how surfaces are predrawn, let’s break down the code used to draw SadConsole. SadConsole is implemented as a MonoGame component, <a href="https://github.com/Thraka/SadConsole/blob/master/src/SadConsole.Shared/Graphics.MonoGame/SadConsoleGameComponent.cs" target="_blank" rel="noopener"><code>SadConsole.Game.SadConsoleGameComponent</code></a>, here is the <code>Draw</code> method.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>(<span class="params">GameTime gameTime</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Settings.DoDraw)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> oldViewPort = GraphicsDevice.Viewport;</span><br><span class="line">        Global.GameTimeRender = gameTime;</span><br><span class="line">        Global.GameTimeElapsedRender = gameTime.ElapsedGameTime.TotalSeconds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clear draw calls for next run</span></span><br><span class="line">        Global.DrawCalls.Clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure all items in the screen are drawn. (Build a list of draw calls)</span></span><br><span class="line">        Global.CurrentScreen?.Draw(gameTime.ElapsedGameTime);</span><br><span class="line"></span><br><span class="line">        SadConsole.Game.OnDraw?.Invoke(gameTime);</span><br></pre></td></tr></table></figure>
<p>The above code resets all of the previous frame’s draw calls. The current screen has <code>Draw</code> called on it which should build a new list of draw calls. A callback is then invoked.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Render to the global output texture</span></span><br><span class="line">GraphicsDevice.SetRenderTarget(Global.RenderOutput);</span><br><span class="line">GraphicsDevice.Clear(Settings.ClearColor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Render each draw call</span></span><br><span class="line">Global.SpriteBatch.Begin(SpriteSortMode.Deferred, BlendState.NonPremultiplied, SamplerState.PointClamp, DepthStencilState.DepthRead, RasterizerState.CullNone);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> call <span class="keyword">in</span> Global.DrawCalls)</span><br><span class="line">&#123;</span><br><span class="line">    call.Draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Global.SpriteBatch.End();</span><br><span class="line">GraphicsDevice.SetRenderTarget(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>The above code tells the graphics device to draw to the final rendered texture. Each draw call is then then run. Afterwards, the graphics device is reset to draw to the screen.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        GraphicsDevice.Viewport = oldViewPort;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we're going to draw to the screen, do it.</span></span><br><span class="line">        <span class="keyword">if</span> (Settings.DoFinalDraw)</span><br><span class="line">        &#123;</span><br><span class="line">            Global.SpriteBatch.Begin(SpriteSortMode.Deferred, BlendState.NonPremultiplied, SamplerState.PointClamp, DepthStencilState.DepthRead, RasterizerState.CullNone);</span><br><span class="line">            Global.SpriteBatch.Draw(Global.RenderOutput, Global.RenderRect, Color.White);</span><br><span class="line">            Global.SpriteBatch.End();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Finally, if the <code>Settings.DoFinalDraw</code> is <code>true</code>, the final render texture is then drawn to the screen. Why does this <code>DoFinalDraw</code> gate exist? This allows you to integrate SadConsole into an existing game. For example, if you had a 3D FPS where the player can walk up to and use a computer in the game, you can use SadConsole to process and draw. Then that final texture created by SadConsole could be mapped to the 3D computer object.</p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	

	</div> <!-- col-md-9/col-md-12 -->
		
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2018 Thraka
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
