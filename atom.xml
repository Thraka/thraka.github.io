<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thraka&#39;s Home</title>
  
  <subtitle>Home of SadConsole &amp; more</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sadconsole.com/"/>
  <updated>2019-01-05T21:03:39.538Z</updated>
  <id>http://www.sadconsole.com/</id>
  
  <author>
    <name>Thraka</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Version 7.3 released</title>
    <link href="http://www.sadconsole.com/2019/01/05/Version-7-3-released/"/>
    <id>http://www.sadconsole.com/2019/01/05/Version-7-3-released/</id>
    <published>2019-01-05T21:00:17.000Z</published>
    <updated>2019-01-05T21:03:39.538Z</updated>
    
    <content type="html"><![CDATA[<p>Version 7.3 was released and included a bunch of minor fixes. While this version was being produced, work started on V8.0 which includes radical changes to the key types. I will follow up with a post about that in the future. Both the 8.0 prerelease and 7.3 final versions are on NuGet.</p><h5 id="changes"><a class="markdownIt-Anchor" href="#changes"></a> Changes</h5><p>Here are the changes since 7.0:</p><p><strong>12/29/2018 V7.3.0</strong></p><ul><li>Windows now default MoveToFrontOnMouseClick = true.</li><li>Consoles are brought forward and focused via LeftMouseDown instead of LeftMouseClick. (Thanks VGA256) #188</li><li>You can set ListBox.SelectedItem = null now (Thanks darrellp) #183</li><li>TextBox supports moving the cursor and inserting characters now (Thanks darrellp) #145</li><li>Window could steal the mouse focus while dragging some other control across the title bar (Thanks VGA256) #165</li><li>ColoredString.Parse now uses CultureInvariant (Thanks GPugnet) #173</li><li>SadConsole.Standard was missing the non extended font embedded resource.</li><li>Various helper methods in ColoredGlyph, ColoredString, and SurfaceBase added (Thanks INeedAUniqueUsername) #187</li></ul><p><strong>11/19/2018 V7.2.0</strong></p><ul><li>ControlsConsole.Controls collection now uses a foreach loop to make sure the collection is not modified when processing the mouse.</li><li>Button theme would crash if ShowEnds was on and the width of the button was &lt; 3. (reported by Hoonius)</li><li>Renamed and promoted the method that forwarded entity animation states to the entity: OnAnimationStateChanged. Override this on custom entities to detect the state changes.</li><li>Blink event did not respect the BlinkCounter property. (reported by Hoonius)</li><li>Default font is now a non-extended IBM 8x16 font.</li><li>Added SadConsole.Settings.UseDefaultExtendedFont setting and when set to true, loads the IBM 8x16 extended font instead of the normal font. Must be set before creating the game.</li></ul><p><strong>10/18/2018 V7.1.0</strong></p><ul><li>Moved SurfaceBase.GetIndexFromPoint to Helpers class.</li><li>Fixed bug in EntityManager that did not remove entity/hotspot/zone parents when the EntityManager’s parent was cleared.</li><li>EntityManager does not support .Clear calls on collections. Instead, use the RemoveAll extension method.</li><li>An extension method was added: SurfaceBase.CenterViewPortOnPoint</li><li>An extension method was added: Rectangle.CenterOnPoint</li></ul><p><strong>09/08/2018 V7.0.3 / 7.0.4</strong></p><ul><li>Fixed bug with textbox displaying two carets.</li><li>If TextBox was first control in console, rendering was wrong.</li><li>Added int overload for Helpers.*Flag related methods.</li></ul><p><strong>08/30/2018 V7.0.2</strong></p><ul><li>Fixed render bug with Entity/Animation if no parent was attached.</li><li>Fixed ColoredString + operator.</li><li>SadConsole IBM Extended font embedded in library now.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Version 7.3 was released and included a bunch of minor fixes. While this version was being produced, work started on V8.0 which includes 
      
    
    </summary>
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/categories/SadConsole/"/>
    
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/tags/SadConsole/"/>
    
      <category term="v7" scheme="http://www.sadconsole.com/tags/v7/"/>
    
  </entry>
  
  <entry>
    <title>Version 7.0 Completed</title>
    <link href="http://www.sadconsole.com/2018/08/30/version-7-0-completed/"/>
    <id>http://www.sadconsole.com/2018/08/30/version-7-0-completed/</id>
    <published>2018-08-31T01:39:02.000Z</published>
    <updated>2018-08-30T21:01:04.106Z</updated>
    
    <content type="html"><![CDATA[<p>Version 7.0 has been released to <a href="https://www.nuget.org/packages/SadConsole/" target="_blank" rel="noopener">NuGet</a>!!</p><p>This release was driven by valuable feedback from you! I think this will make it a lot easier to work with surfaces, animations, and objects in general.</p><p>I did remove the world generation code. It felt very specific to a game scenario and I have plans to release a new library that adds more game functions (such as random world/dungeon generation) and plays very nicely with <a href="https://github.com/Chris3606/GoRogue" target="_blank" rel="noopener">GoRogue</a>.</p><p>I’ve compiled (but not released) a  .NET Standard 2.0 version of SadConsole that will replace the existing release. This will make it easy to use with .NET Core.</p><p>The <a href="http://sadconsole.com/docs/" target="_blank" rel="noopener">documentation</a> is just about finished. I’ll have that done tonight.</p><h5 id="next-goals"><a class="markdownIt-Anchor" href="#next-goals"></a> Next goals</h5><ol><li>Update the Sample Games in the GitHub repo.</li><li>Release the .NET Standard 2.0 build.</li><li>Start work on the GoRogue-SadConsole game helper.</li><li>Start work on redoing the Roguelike tutorial.</li></ol><h5 id="notes-about-the-changes"><a class="markdownIt-Anchor" href="#notes-about-the-changes"></a> Notes about the changes</h5><p>The NuGet release notes details some of these changes but the most notible are:</p><ul><li><p>SurfaceEditor has been removed and is now implemented on SurfaceBase directly.</p><p>You do not need to use a <code>SurfaceEditor</code> type to edit surfaces. You won’t really notice this change on the <code>Console</code> as it had inherited from <code>SurfaceEditor</code>. <code>Console</code> is now a surface, and all surfaces can be edited directly.</p></li><li><p>Console no longer combines Renderer and TextSurface for drawing.</p><p><code>Console</code> had a <code>TextSurface</code> property that allowed you to swap out different surfaces that represented the visual of the console. This has gone away. A <code>Console</code> is now a surface.</p></li><li><p>SadConsole.Serialization uses Newtonsoft.Json instead of the default .NET classes.</p><p>The <code>Newtonsoft.Json</code> library is much more capable of de/serializing objects. Compression is also supported now.</p></li><li><p>Removed GameHelpers namespace and GameObject renamed to Entity.</p><p>GameHelpers had the GameObject and world generation code. The GameObject is now <code>SadConsole.Entities.Entity</code> and the world generation code has been removed. The generation code will be added to a different library in the future.</p><p>If you were previously using the world generation code, you can use a temporary library <a href="https://github.com/Thraka/SadConsole/issues/149" target="_blank" rel="noopener">here</a>.</p></li><li><p>Control themes completely rewritten. Themes control all drawing for a control now.</p><p>Previously the control itself would draw itself using some color settings from a theme object. Now the theme object actually <a href="https://github.com/Thraka/SadConsole/blob/c2103c218f829433d147669fc3a4fc59957fecff/src/SadConsole.Shared/Themes/ButtonTheme.cs#L44" target="_blank" rel="noopener">draws the entire control</a> using various settings from the control instance itself.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Version 7.0 has been released to &lt;a href=&quot;https://www.nuget.org/packages/SadConsole/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NuGet&lt;/a&gt;!!&lt;/p&gt;
&lt;p&gt;T
      
    
    </summary>
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/categories/SadConsole/"/>
    
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/tags/SadConsole/"/>
    
      <category term="v7" scheme="http://www.sadconsole.com/tags/v7/"/>
    
  </entry>
  
  <entry>
    <title>New Theme System for 7.0</title>
    <link href="http://www.sadconsole.com/2018/08/12/new-theme-system-for-7-0/"/>
    <id>http://www.sadconsole.com/2018/08/12/new-theme-system-for-7-0/</id>
    <published>2018-08-13T05:14:59.000Z</published>
    <updated>2018-08-14T00:07:43.094Z</updated>
    
    <content type="html"><![CDATA[<p>The last two weeks have been pretty busy, but I’ve been slowly banging around on the controls redesign for SadConsole. One thing that I didn’t like with how the controls worked was that each control does its own drawing. This means that if you have a button control, and you wanted it to draw a border around it all of the time, you had to create a new button class; adding whole new types of controls just to tweak the drawing of an existing control.</p><p>The new system for 7.0 decouples the drawing from the control, putting all drawing in the theme assigned to the control. To create a new button look-and-feel, create a new theme type and customize the draw method. This new “the theme draws the control” system is also implemented on the <code>ControlsConsole</code> and <code>Window</code> types.</p><p>To test this out I create 3 types of themes for the button type:</p><ol><li>The normal button from v6.</li><li>A 3d button.</li><li>Bordered 3d button (which uses the SadConsole extended character sheet).</li></ol><img src="/2018/08/12/new-theme-system-for-7-0/new-button-themes.gif" title="3d themes for buttons in sadconsole">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;The last two weeks have been pretty busy, but I’ve been slowly banging around on the controls redesign for SadConsole. One thing that I d
      
    
    </summary>
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/categories/SadConsole/"/>
    
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/tags/SadConsole/"/>
    
      <category term="v7" scheme="http://www.sadconsole.com/tags/v7/"/>
    
  </entry>
  
  <entry>
    <title>Console changes with 7.0</title>
    <link href="http://www.sadconsole.com/2018/08/02/Console-changes-with-7-0/"/>
    <id>http://www.sadconsole.com/2018/08/02/Console-changes-with-7-0/</id>
    <published>2018-08-02T19:59:41.000Z</published>
    <updated>2018-08-02T20:52:09.658Z</updated>
    
    <content type="html"><![CDATA[<p>As the previous entry stated, the <code>Console</code> type is changing. As an example take creating a border on the outside of a console. This involved creating a derived class that handled the drawing of the console itself and the border. There was a lot to do just to create the border.</p><h3 id="v6-style"><a class="markdownIt-Anchor" href="#v6-style"></a> V6 style</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BorderedConsole</span>: <span class="title">Console</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> SadConsole.Surfaces.BasicSurface border;</span><br><span class="line">    <span class="keyword">private</span> DrawCallSurface drawCall;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BorderedConsole</span>(<span class="params"><span class="keyword">int</span> width, <span class="keyword">int</span> height</span>):<span class="title">base</span>(<span class="params">width, height</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        border = <span class="keyword">new</span> BasicSurface(width + <span class="number">2</span>, height + <span class="number">2</span>);</span><br><span class="line">        border.DefaultBackground = Color.Black;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> editor = <span class="keyword">new</span> SurfaceEditor(border);</span><br><span class="line">        editor.Clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> borderBox = Box.Thick();</span><br><span class="line">        borderBox.Position = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        borderBox.Width = border.Width;</span><br><span class="line">        borderBox.Height = border.Height;</span><br><span class="line">        borderBox.Draw(editor);</span><br><span class="line"></span><br><span class="line">        Renderer.Render(border);</span><br><span class="line"></span><br><span class="line">        drawCall = <span class="keyword">new</span> DrawCallSurface(border, CalculatedPosition, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        Print(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Hello inside the border"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>(<span class="params">TimeSpan delta</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Global.DrawCalls.Clear();</span><br><span class="line">        drawCall.Position = border.Font.GetWorldPosition((CalculatedPosition - <span class="keyword">new</span> Point(<span class="number">1</span>))).ToVector2();</span><br><span class="line">        Global.DrawCalls.Add(drawCall);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">base</span>.Draw(delta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="v7-style"><a class="markdownIt-Anchor" href="#v7-style"></a> V7 style</h3><p>In 7.0 this is much easier, and it doesn’t require creating a derived class.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> console = <span class="keyword">new</span> SadConsole.Console(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> border = <span class="keyword">new</span> SadConsole.Surfaces.Basic(console.Width + <span class="number">2</span>, console.Height + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">console.Position = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">console.Print(<span class="string">"Hello inside the border"</span>);</span><br><span class="line"></span><br><span class="line">border.DrawBox(<span class="keyword">new</span> Rectangle(<span class="number">0</span>, <span class="number">0</span>, border.Width, border.Height), </span><br><span class="line">               foreground: Color.White, background: Color.Black, </span><br><span class="line">               connectedLineStyle: SurfaceBase.ConnectedLineThick);</span><br><span class="line"></span><br><span class="line">border.Draw(TimeSpan.Zero);</span><br><span class="line">border.Position = <span class="keyword">new</span> Point(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">console.Children.Add(border);</span><br></pre></td></tr></table></figure><p>Sure, some code is missing because it’s easier to draw shapes now, but this also requires less overhead in types you create just to do simple things. And since any surface is now a positionable and drawable object, it can be added as a child to a console. Now the position of the border is automatically kept in place.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;As the previous entry stated, the &lt;code&gt;Console&lt;/code&gt; type is changing. As an example take creating a border on the outside of a console
      
    
    </summary>
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/categories/SadConsole/"/>
    
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/tags/SadConsole/"/>
    
      <category term="v7" scheme="http://www.sadconsole.com/tags/v7/"/>
    
  </entry>
  
  <entry>
    <title>Major changes to be included in 7.0</title>
    <link href="http://www.sadconsole.com/2018/08/01/Major-changes-to-be-included-in-7-0/"/>
    <id>http://www.sadconsole.com/2018/08/01/Major-changes-to-be-included-in-7-0/</id>
    <published>2018-08-02T01:23:16.000Z</published>
    <updated>2018-08-02T20:28:57.388Z</updated>
    
    <content type="html"><![CDATA[<p>A month and a half into the V7.0 rewrite, and I’m about 90% complete. There are some major changes to how a <code>console</code> and <code>surfaces</code> work. A friend of mine did a nice writeup about how SadConsole looks to a first-time user. The <a href="https://github.com/Thraka/SadConsole/pull/139" target="_blank" rel="noopener">current pull request</a> on GitHub shows all of the changes so far; 200+ files changed.</p><p>The major change is that the whole concept of changable backing surfaces is gone. Prior to 7.0, a console was the editor for a <code>TextSurface</code> property, a property represented the actual graphical text surface of a console. You could easily change the surface in/out of the console. There was also a <code>SurfaceEditor</code> class (which console inherited from) that could be directed at any <code>TextSurface</code> object, and edit it. This <code>SurfaceEditor</code> type was what had all of the editing methods such as <code>SetForeground</code> and <code>Print</code>.</p><p>This has been changed to where every <code>Surface</code> type itself (ex: layered, animated, basic) has all of the methods needed to manipulate the cells themselves directly. Surfaces are also positionable and drawable without the need a <code>Console</code>, if you don’t want one. Previously every surface had to be wrapped by a console or by a bunch of code. A <code>Console</code> now inherits from a surface base class which means a console <strong>is</strong> a surface now.</p><p>I think this will greatly simplify the getting started aspects of the engine. I’ll have more to talk about soon.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A month and a half into the V7.0 rewrite, and I’m about 90% complete. There are some major changes to how a &lt;code&gt;console&lt;/code&gt; and &lt;cod
      
    
    </summary>
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/categories/SadConsole/"/>
    
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/tags/SadConsole/"/>
    
      <category term="v7" scheme="http://www.sadconsole.com/tags/v7/"/>
    
  </entry>
  
  <entry>
    <title>Plans for 7.0</title>
    <link href="http://www.sadconsole.com/2018/06/16/Plans-for-7-0/"/>
    <id>http://www.sadconsole.com/2018/06/16/Plans-for-7-0/</id>
    <published>2018-06-17T02:15:52.000Z</published>
    <updated>2018-08-02T20:28:49.371Z</updated>
    
    <content type="html"><![CDATA[<p>It’s been over a year since my last post. Unacceptable! I need to keep up on this.</p><p>Over the last year, <strong>SadConsole</strong> has seen a lot of minor changes and improvement. A few new controls were added, various input bugs fixed, windowing adjust, it’s been fun. <strong>SadConsole</strong> as a whole is pretty solid and good. I now want to start playing with some fun enhancements such as angled cells, cell decorations (such as underline), TrueType fonts, that kind of fun stuff.</p><p>The next major release (it has to be a major release because some things are breaking) is going to be <em>7.0</em>. I’ve created a <a href="https://github.com/Thraka/SadConsole/projects/1#card-10550416" target="_blank" rel="noopener">GitHub project</a> to track all of things to be adressed. Some things may get cut and new items may be added. If you have an idea, please add a new issue to the repository.</p><p>I have a few more blog posts coming up soon, with screenshots and all! Stay tuned…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;It’s been over a year since my last post. Unacceptable! I need to keep up on this.&lt;/p&gt;
&lt;p&gt;Over the last year, &lt;strong&gt;SadConsole&lt;/strong&gt;
      
    
    </summary>
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/categories/SadConsole/"/>
    
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/tags/SadConsole/"/>
    
      <category term="v7" scheme="http://www.sadconsole.com/tags/v7/"/>
    
  </entry>
  
  <entry>
    <title>Engine Revision Completed</title>
    <link href="http://www.sadconsole.com/2017/03/18/engine-revision-completed/"/>
    <id>http://www.sadconsole.com/2017/03/18/engine-revision-completed/</id>
    <published>2017-03-19T01:29:11.000Z</published>
    <updated>2017-03-19T17:59:13.893Z</updated>
    
    <content type="html"><![CDATA[<p>Yahhh!! I’ve completed the rewrite! Wiki, NuGet, GitHub have all been updated.</p><ul><li><a href="https://www.nuget.org/packages/sadconsole" target="_blank" rel="noopener">NuGet package</a></li><li><a href="https://github.com/Thraka/SadConsole" target="_blank" rel="noopener">GitHub</a></li><li><a href="https://github.com/Thraka/SadConsole/wiki/NuGet-Starter-MonoGame" target="_blank" rel="noopener">Getting started</a></li></ul><a id="more"></a><p>Here are the notes from the readme.</p><p>A lot of refactoring has happened. Many of the types in SadConsole have been moved around to a more logical position and a lot of redundancy has been removed.</p><p>For example, the <strong>Console</strong> type used to be located at the <code>SadConsole.Consoles.Console</code> which felt very obtuse. <strong>Console</strong> is a core type that doesn’t need its own namespace, much like <strong>Cell</strong>. This type is now located in the root namespace <code>SadConsole</code>.</p><p>Other things have simplified naming too, like <code>Console.CanUseKeyboard</code> is just <code>Console.UseKeyboard</code> now.</p><h2 id="core-engine"><a class="markdownIt-Anchor" href="#core-engine"></a> Core engine</h2><p><code>SadConsole.Engine</code> has been removed. Its role was to coordinate all the parts of SadConsole. Instead this has been split into three parts, <code>SadConsole.Global</code> which represents state (time passed, keyboard/mouse, current thing to render), <code>SadConsole.Game</code> which is the <code>MonoGame.Game</code> instance, and <code>SadConsole.Settings</code> which provides full screen, toggle drawing on/off etc.</p><table><thead><tr><th>Class</th><th></th></tr></thead><tbody><tr><td>SadConsole.Global</td><td>Global state, like time elapsed, keyboard/mouse input state, the active thing to render.</td></tr><tr><td>SadConsole.Game</td><td><code>Microsoft.Xna.Framework.Game</code> game instance that you can run instead of providing your own.</td></tr><tr><td>SadConsole.Settings</td><td>Various settings like fullscreen, device clear color, enable/disable keyboard or mouse, other settings.</td></tr></tbody></table><h2 id="core-types"><a class="markdownIt-Anchor" href="#core-types"></a> Core types</h2><p>The <code>SadConsole.Consoles</code> namespace does not exist anymore and is instead broken up into two different namespaces that better represents the types contained in it:</p><table><thead><tr><th>Namespace</th><th></th></tr></thead><tbody><tr><td>SadConsole.Surfaces</td><td>All types of surfaces that are attached to a Console.</td></tr><tr><td>SadConsole.Renderers</td><td>All renderers that render surfaces and are attached to a Console.</td></tr></tbody></table><p>The <strong>TextSurface</strong> naming convention has been simplified to <strong>Surface</strong>. And some of the interface and base class complexity of the <strong>TextSurface</strong> stuff has been simplified into fewer types.</p><h2 id="rendering"><a class="markdownIt-Anchor" href="#rendering"></a> Rendering</h2><p>The rendering system in SadConsole has had some improvements. Instead of each ** Renderer**  having its own ** SpriteBatch** , there is a single <code>SadConosle.Global.SpriteBatch</code> which is reused by all renderers. This reduces memory and reduces CPU cycles that were wasted every time a renderer was created.</p><p>Each <strong>Surface</strong> now provides a <strong>RenderTarget2D</strong> type which is a texture. Whenever a surface is rendered, it is drawn onto this texture. At the end of the global Draw call, all surfaces that are in the drawing pipeline are rendered to a single <strong>RenderTarget2D</strong> texture at <code>SadConsole.Global.RenderOutput</code>. This final texture (which contains all drawing from SadConsole) is then drawn to the screen. This simplifies fullscreen and stretch modes. This new system also allows anyone to bypass any part of SadConsole rendering and use the rendered textures to draw on any sort of 3D model or scene of their game. For example, you could build up a 3D scene of an old computer terminal and then use SadConsole on the screen of the computer.</p><p>The rendering system is now completely cached. Each <strong>ISurface</strong> type has a <strong>IsDirty</strong> flag which causes the backing <strong>RenderTarget2D</strong> to be updated.</p><h2 id="notable-types"><a class="markdownIt-Anchor" href="#notable-types"></a> Notable types</h2><p>Here is a list of types that have changed and what replaced them. The root <code>SadConsole</code> namespace is implied in all of these.</p><table><thead><tr><th>Old Class</th><th>New Class</th></tr></thead><tbody><tr><td>Engine</td><td>Replaced by <strong>Global</strong>, <strong>Game</strong>, and <strong>Settings</strong>.</td></tr><tr><td>ICellAppearance</td><td>Removed - Use <strong>Cell</strong>.</td></tr><tr><td>CellAppearance</td><td>Removed - Use <strong>Cell</strong>.</td></tr><tr><td>Consoles.IConsole</td><td>IConsole. Still exists, implements <strong>IScreen</strong> now.</td></tr><tr><td>Consoles.IConsoleList</td><td>Removed.</td></tr><tr><td>Consoles.Console</td><td>Console</td></tr><tr><td>Consoles.ConsoleList</td><td>Removed. All <strong>IScreen</strong> types have both <strong>Parent</strong> and <strong>Children</strong> properties.</td></tr><tr><td>Consoles.ITextSurface</td><td>Surfaces.ISurface</td></tr><tr><td>Consoles.TextSurfaceBasic</td><td>Removed. Merged into <strong>Surfaces.Surface</strong></td></tr><tr><td>Consoles.TextSurface</td><td>Surfaces.BasicSurface</td></tr><tr><td>Consoles.TextSurfaceView</td><td>Surfaces.SurfaceView</td></tr><tr><td>Consoles.AnimatedTextSurface</td><td>Surfaces.AnimatedSurface</td></tr><tr><td>Consoles.LayeredTextSurface</td><td>Surfaces.LayeredSurface</td></tr><tr><td>Consoles.Cursor</td><td>Cursor</td></tr><tr><td>Consoles.SurfaceEditor</td><td>Surfaces.SurfaceEditor</td></tr><tr><td>Consoles.ITextSurfaceRenderer</td><td>Renderers.ISurfaceRenderer</td></tr><tr><td>Consoles.TextSurfaceRenderer</td><td>Renderers.SurfaceRenderer</td></tr><tr><td>Consoles.LayeredTextRenderer</td><td>Renderers.LayeredSurfaceRenderer</td></tr><tr><td>Consoles.ITextSurfaceRendererUpdate</td><td>Removed - All surfaces support cached rendering.</td></tr><tr><td>Consoles.CachedTextSurfaceRenderer</td><td>Removed - All surfaces support cached rendering.</td></tr><tr><td>Input.MouseInfo</td><td>Renamed to Input.Mouse</td></tr><tr><td>Input.KeyboardInfo</td><td>Renamed to Input.Keyboard</td></tr></tbody></table><p>Besides the <strong>Consoles</strong> namespace, startup, and <strong>Engine</strong> -&gt; <strong>Global</strong> changes, not much else has changed.</p><p>Some methods and/or properties have been renamed. Here are some of them.</p><table><thead><tr><th>Old name</th><th>New name</th></tr></thead><tbody><tr><td>Input.Keyboard.ProcessKeys</td><td>Input.Keyboard.Process</td></tr><tr><td>Input.Mouse.ProcessMouse</td><td>Input.Mouse.Process</td></tr><tr><td>Engine.ActiveConsole</td><td>Global.InputTargets – This is a new type that allows a Push/Pop/Set system for who gets keyboard/exclusive mouse input</td></tr></tbody></table><h2 id="input"><a class="markdownIt-Anchor" href="#input"></a> Input</h2><p>Input has been overhauled a bit. Keyboard is mostly the same except for some minor method refactoring. Mouse has change a lot. Previously each console evaluated mouse state for itself. This is no longer how mouse input works. Instead mouse input is driven by the <code>SadConsole.Input.Mouse.Update</code> method which cycles through the <code>SadConsole.Global.Screen</code> gathering all console types. Then, each console has the <code>ProcessMouse</code> method called. If <code>true</code> is returned, mouse processing stops. This happens unless the <code>Global.InputTargets.Console</code> has the <code>IsExclusiveMouse</code> property set to <code>true</code>. If <code>true</code>, mouse is always sent to this console and never to anything else.</p><h2 id="startup-code"><a class="markdownIt-Anchor" href="#startup-code"></a> Startup code</h2><p>The code to start SadConsole from a dedicated SadConsole project is pretty much the same. But now that <code>Engine</code> is gone, <code>Global</code> is used and the names of the draw/update events are simplier. They also are direct delegates instead of event.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Setup the engine and creat the main window.</span></span><br><span class="line">    SadConsole.Game.Create(<span class="string">"IBM.font"</span>, <span class="number">80</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook the start event so we can add consoles to the system.</span></span><br><span class="line">    SadConsole.Game.OnInitialize = Init;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook the update event that happens each frame so we can trap keys and respond.</span></span><br><span class="line">    SadConsole.Game.OnUpdate = Update;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook the "after render" even though we're not using it.</span></span><br><span class="line">    SadConsole.Game.OnDraw = DrawFrame;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// Start the game.</span></span><br><span class="line">    SadConsole.Game.Instance.Run();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Code here will not run until the game has shut down.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawFrame</span>(<span class="params">GameTime time</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Custom drawing. You don't usually have to do this.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">GameTime time</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Called each logic update.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Any setup</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Yahhh!! I’ve completed the rewrite! Wiki, NuGet, GitHub have all been updated.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nuget.org/packages/sadconsole&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NuGet package&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Thraka/SadConsole&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Thraka/SadConsole/wiki/NuGet-Starter-MonoGame&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Getting started&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/categories/SadConsole/"/>
    
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/tags/SadConsole/"/>
    
  </entry>
  
  <entry>
    <title>Engine Revision</title>
    <link href="http://www.sadconsole.com/2017/03/08/engine-revision/"/>
    <id>http://www.sadconsole.com/2017/03/08/engine-revision/</id>
    <published>2017-03-08T19:34:22.000Z</published>
    <updated>2017-03-19T17:58:56.688Z</updated>
    
    <content type="html"><![CDATA[<p>Over the last two months I’ve spent a lot of time looking at how SadConsole is put together. Specifically, paying attention to namespaces and class names. There a few complexities in the object model that I wanted to address and just make things simpler. I’ve come to a point now where I would guess that I’m 99% complete on implementing these changes, and I’m extremely happy with how things have turned out.</p><p>Two major changes that I’ve figured out impact you as a coder.</p><ol><li>All four libraries (Core, Ansi, Controls, GameHelpers) have been merged into a single library: <code>SadConsole.dll</code>.</li><li>Instead of two libraries, one for OpenGl and one for DirectX, a single library handles both.</li></ol><p>Originally I thought I needed both types of libraries, however it turns out that you (creating the game) choose which target (OpenGL or DirectX) based on which MonoGame you choose. SadConsole will just play along without a problem.</p><p>The internal rendering and processing system has also changed.</p><a id="more"></a><p>Here are the notes from the readme.</p><p>The preview release NuGet package is at <a href="https://www.nuget.org/packages/SadConsole/" target="_blank" rel="noopener">https://www.nuget.org/packages/SadConsole/</a></p><p>A lot of refactoring has happened. Many of the types in SadConsole have been moved around to a more logical position and a lot of redundancy has been removed.</p><p>For example, the <strong>Console</strong> type used to be located at the <code>SadConsole.Consoles.Console</code> which felt very obtuse. <strong>Console</strong> is a core type that doesn’t need its own namespace, much like <strong>Cell</strong>. This type is now located in the root namespace <code>SadConsole</code>.</p><p>Other things have simplified naming too, like <code>Console.CanUseKeyboard</code> is just <code>Console.UseKeyboard</code> now.</p><h2 id="core-engine"><a class="markdownIt-Anchor" href="#core-engine"></a> Core engine</h2><p><code>SadConsole.Engine</code> has been removed. Its role was to coordinate all the parts of SadConsole. Instead this has been split into three parts, <code>SadConsole.Global</code> which represents state (time passed, keyboard/mouse, current thing to render), <code>SadConsole.Game</code> which is the <code>MonoGame.Game</code> instance, and <code>SadConsole.Settings</code> which provides full screen, toggle drawing on/off etc.</p><table><thead><tr><th>Class</th><th></th></tr></thead><tbody><tr><td>SadConsole.Global</td><td>Global state, like time elapsed, keyboard/mouse input state, the active thing to render.</td></tr><tr><td>SadConsole.Game</td><td><code>Microsoft.Xna.Framework.Game</code> game instance that you can run instead of providing your own.</td></tr><tr><td>SadConsole.Settings</td><td>Various settings like fullscreen, device clear color, enable/disable keyboard or mouse, other settings.</td></tr></tbody></table><h2 id="core-types"><a class="markdownIt-Anchor" href="#core-types"></a> Core types</h2><p>The <code>SadConsole.Consoles</code> namespace does not exist anymore and is instead broken up into two different namespaces that better represents the types contained in it:</p><table><thead><tr><th>Namespace</th><th></th></tr></thead><tbody><tr><td>SadConsole.Surfaces</td><td>All types of surfaces that are attached to a Console.</td></tr><tr><td>SadConsole.Renderers</td><td>All renderers that render surfaces and are attached to a Console.</td></tr></tbody></table><p>The <strong>TextSurface</strong> naming convention has been simplified to <strong>Surface</strong>. And some of the interface and base class complexity of the <strong>TextSurface</strong> stuff has been simplified into fewer types.</p><h2 id="rendering"><a class="markdownIt-Anchor" href="#rendering"></a> Rendering</h2><p>The rendering system in SadConsole has had some improvements. Instead of each ** Renderer**  having its own ** SpriteBatch** , there is a single <code>SadConosle.Global.SpriteBatch</code> which is reused by all renderers. This reduces memory and reduces CPU cycles that were wasted every time a renderer was created.</p><p>Each <strong>Surface</strong> now provides a <strong>RenderTarget2D</strong> type which is a texture. Whenever a surface is rendered, it is drawn onto this texture. At the end of the global Draw call, all surfaces that are in the drawing pipeline are rendered to a single <strong>RenderTarget2D</strong> texture at <code>SadConsole.Global.RenderOutput</code>. This final texture (which contains all drawing from SadConsole) is then drawn to the screen. This simplifies fullscreen and stretch modes. This new system also allows anyone to bypass any part of SadConsole rendering and use the rendered textures to draw on any sort of 3D model or scene of their game. For example, you could build up a 3D scene of an old computer terminal and then use SadConsole on the screen of the computer.</p><p>The rendering system is now completely cached. Each <strong>ISurface</strong> type has a <strong>IsDirty</strong> flag which causes the backing <strong>RenderTarget2D</strong> to be updated.</p><h2 id="notable-types"><a class="markdownIt-Anchor" href="#notable-types"></a> Notable types</h2><p>Here is a list of types that have changed and what replaced them. The root <code>SadConsole</code> namespace is implied in all of these.</p><table><thead><tr><th>Old Class</th><th>New Class</th></tr></thead><tbody><tr><td>Engine</td><td>Replaced by <strong>Global</strong>, <strong>Game</strong>, and <strong>Settings</strong>.</td></tr><tr><td>ICellAppearance</td><td>Removed - Use <strong>Cell</strong>.</td></tr><tr><td>CellAppearance</td><td>Removed - Use <strong>Cell</strong>.</td></tr><tr><td>Consoles.IConsole</td><td>IConsole. Still exists, implements <strong>IScreen</strong> now.</td></tr><tr><td>Consoles.IConsoleList</td><td>Removed.</td></tr><tr><td>Consoles.Console</td><td>Console</td></tr><tr><td>Consoles.ConsoleList</td><td>Removed. All <strong>IScreen</strong> types have both <strong>Parent</strong> and <strong>Children</strong> properties.</td></tr><tr><td>Consoles.ITextSurface</td><td>Surfaces.ISurface</td></tr><tr><td>Consoles.TextSurfaceBasic</td><td>Removed. Merged into <strong>Surfaces.Surface</strong></td></tr><tr><td>Consoles.TextSurface</td><td>Surfaces.BasicSurface</td></tr><tr><td>Consoles.TextSurfaceView</td><td>Surfaces.SurfaceView</td></tr><tr><td>Consoles.AnimatedTextSurface</td><td>Surfaces.AnimatedSurface</td></tr><tr><td>Consoles.LayeredTextSurface</td><td>Surfaces.LayeredSurface</td></tr><tr><td>Consoles.Cursor</td><td>Cursor</td></tr><tr><td>Consoles.SurfaceEditor</td><td>Surfaces.SurfaceEditor</td></tr><tr><td>Consoles.ITextSurfaceRenderer</td><td>Renderers.ISurfaceRenderer</td></tr><tr><td>Consoles.TextSurfaceRenderer</td><td>Renderers.SurfaceRenderer</td></tr><tr><td>Consoles.LayeredTextRenderer</td><td>Renderers.LayeredSurfaceRenderer</td></tr><tr><td>Consoles.ITextSurfaceRendererUpdate</td><td>Removed - All surfaces support cached rendering.</td></tr><tr><td>Consoles.CachedTextSurfaceRenderer</td><td>Removed - All surfaces support cached rendering.</td></tr><tr><td>Input.MouseInfo</td><td>Renamed to Input.Mouse</td></tr><tr><td>Input.KeyboardInfo</td><td>Renamed to Input.Keyboard</td></tr></tbody></table><p>Besides the <strong>Consoles</strong> namespace, startup, and <strong>Engine</strong> -&gt; <strong>Global</strong> changes, not much else has changed.</p><p>Some methods and/or properties have been renamed. Here are some of them.</p><table><thead><tr><th>Old name</th><th>New name</th></tr></thead><tbody><tr><td>Input.Keyboard.ProcessKeys</td><td>Input.Keyboard.Process</td></tr><tr><td>Input.Mouse.ProcessMouse</td><td>Input.Mouse.Process</td></tr><tr><td>Engine.ActiveConsole</td><td>Global.InputTargets – This is a new type that allows a Push/Pop/Set system for who gets keyboard/exclusive mouse input</td></tr></tbody></table><h2 id="input"><a class="markdownIt-Anchor" href="#input"></a> Input</h2><p>Input has been overhauled a bit. Keyboard is mostly the same except for some minor method refactoring. Mouse has change a lot. Previously each console evaluated mouse state for itself. This is no longer how mouse input works. Instead mouse input is driven by the <code>SadConsole.Input.Mouse.Update</code> method which cycles through the <code>SadConsole.Global.Screen</code> gathering all console types. Then, each console has the <code>ProcessMouse</code> method called. If <code>true</code> is returned, mouse processing stops. This happens unless the <code>Global.InputTargets.Console</code> has the <code>IsExclusiveMouse</code> property set to <code>true</code>. If <code>true</code>, mouse is always sent to this console and never to anything else.</p><h2 id="startup-code"><a class="markdownIt-Anchor" href="#startup-code"></a> Startup code</h2><p>The code to start SadConsole from a dedicated SadConsole project is pretty much the same. But now that <code>Engine</code> is gone, <code>Global</code> is used and the names of the draw/update events are simplier. They also are direct delegates instead of event.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Setup the engine and creat the main window.</span></span><br><span class="line">    SadConsole.Game.Create(<span class="string">"IBM.font"</span>, <span class="number">80</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook the start event so we can add consoles to the system.</span></span><br><span class="line">    SadConsole.Game.OnInitialize = Init;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook the update event that happens each frame so we can trap keys and respond.</span></span><br><span class="line">    SadConsole.Game.OnUpdate = Update;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook the "after render" even though we're not using it.</span></span><br><span class="line">    SadConsole.Game.OnDraw = DrawFrame;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// Start the game.</span></span><br><span class="line">    SadConsole.Game.Instance.Run();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Code here will not run until the game has shut down.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawFrame</span>(<span class="params">GameTime time</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Custom drawing. You don't usually have to do this.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">GameTime time</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Called each logic update.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Any setup</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Over the last two months I’ve spent a lot of time looking at how SadConsole is put together. Specifically, paying attention to namespaces and class names. There a few complexities in the object model that I wanted to address and just make things simpler. I’ve come to a point now where I would guess that I’m 99% complete on implementing these changes, and I’m extremely happy with how things have turned out.&lt;/p&gt;
&lt;p&gt;Two major changes that I’ve figured out impact you as a coder.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;All four libraries (Core, Ansi, Controls, GameHelpers) have been merged into a single library: &lt;code&gt;SadConsole.dll&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Instead of two libraries, one for OpenGl and one for DirectX, a single library handles both.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Originally I thought I needed both types of libraries, however it turns out that you (creating the game) choose which target (OpenGL or DirectX) based on which MonoGame you choose. SadConsole will just play along without a problem.&lt;/p&gt;
&lt;p&gt;The internal rendering and processing system has also changed.&lt;/p&gt;
    
    </summary>
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/categories/SadConsole/"/>
    
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/tags/SadConsole/"/>
    
  </entry>
  
  <entry>
    <title>Easier Startup</title>
    <link href="http://www.sadconsole.com/2016/08/12/easier-startup/"/>
    <id>http://www.sadconsole.com/2016/08/12/easier-startup/</id>
    <published>2016-08-13T05:16:17.000Z</published>
    <updated>2016-08-13T07:56:54.180Z</updated>
    
    <content type="html"><![CDATA[<p>First, NuGet has been updated with a bunch more fixes. I’m trying my best now to stick with the <a href="http://semver.org/" target="_blank" rel="noopener">semantic versioning</a> format. It’s hard to transition from the old versioning style. It’s also getting harder and harder to not break interface on updates. So I’m really going to try hard to no longer do that.</p><p>Down to business…</p><p>I’ve created new init sequences for SadConsole that removes all the crap that comes with MonoGame. That means if you’re not making a full MonoGame-game where you need all the extra 3D management, you can omit the whole giant <code>game1.cs</code> class and instead use this nice, compact, easy, startup file.</p><a id="more"></a><pre class="highlight"><code class="csharp"><span class="keyword">using</span> System;<span class="keyword">using</span> Console = SadConsole.Consoles.Console;<span class="keyword">using</span> SadConsole.Consoles;<span class="keyword">using</span> Microsoft.Xna.Framework;<span class="keyword">namespace</span> <span class="title">MyNamespace</span>{    <span class="keyword">class</span> <span class="title">Program</span>    {        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)        </span>{            <span class="comment">// Setup the engine and creat the main window.</span>            SadConsole.Engine.Initialize(<span class="string">"IBM.font"</span>, <span class="number">80</span>, <span class="number">25</span>);            <span class="comment">// Hook the start event so we can add consoles to the system.</span>            SadConsole.Engine.EngineStart += Engine_EngineStart;            <span class="comment">// Hook the update event that happens each frame so we can do logic.</span>            SadConsole.Engine.EngineUpdated += Engine_EngineUpdated;            <span class="comment">// Start the game.</span>            SadConsole.Engine.Run();        }        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Engine_EngineStart</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)        </span>{            <span class="keyword">var</span> defaultConsole = (Console)SadConsole.Engine.ActiveConsole;            defaultConsole.Print(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"Welcome to SadConsole"</span>, Color.Aqua, Color.Black);        }        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Engine_EngineUpdated</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)        </span>{            <span class="comment">// Game logic if doing it in a console directly.</span>        }    }}</code></pre><p>Of course that is how to startup with MonoGame. I’m also introducing support for SFML.</p><h3 id="sfml"><a class="markdownIt-Anchor" href="#sfml"></a> SFML</h3><blockquote><p><a href="http://www.sfml-dev.org/" target="_blank" rel="noopener">SFML</a> provides a simple interface to the various components of your PC, to ease the development of games and multimedia applications. It is composed of five modules: system, window, graphics, audio and network.</p></blockquote><p>That is the summary of what SFML website says. It’s a C++ library that someone has lovingly provided a .NET wrapper for on NuGet. I’m using the wrapper.</p><p>Using the SFML version of SadConsole doesn’t really change much from your perspective. While the MonoGame framework itself is cleaner from a game developer perspective, there is a bit of overhead. SFML renders slightly faster.</p><p>The NuGet packages for SFML are</p><ul><li><a href="https://www.nuget.org/packages/SadConsole.Core.SFML/" target="_blank" rel="noopener">https://www.nuget.org/packages/SadConsole.Core.SFML/</a></li><li><a href="https://www.nuget.org/packages/SadConsole.Controls.SFML/" target="_blank" rel="noopener">https://www.nuget.org/packages/SadConsole.Controls.SFML/</a></li><li><a href="https://www.nuget.org/packages/SadConsole.GameHelpers.SFML/" target="_blank" rel="noopener">https://www.nuget.org/packages/SadConsole.GameHelpers.SFML/</a></li><li><a href="https://www.nuget.org/packages/SadConsole.Ansi.SFML/" target="_blank" rel="noopener">https://www.nuget.org/packages/SadConsole.Ansi.SFML/</a></li></ul><p>The starter tutorial for SFML is available <a href="https://github.com/Thraka/SadConsole/wiki/NuGet%20Starter%20SFML" target="_blank" rel="noopener">here</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;First, NuGet has been updated with a bunch more fixes. I’m trying my best now to stick with the &lt;a href=&quot;http://semver.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;semantic versioning&lt;/a&gt; format. It’s hard to transition from the old versioning style. It’s also getting harder and harder to not break interface on updates. So I’m really going to try hard to no longer do that.&lt;/p&gt;
&lt;p&gt;Down to business…&lt;/p&gt;
&lt;p&gt;I’ve created new init sequences for SadConsole that removes all the crap that comes with MonoGame. That means if you’re not making a full MonoGame-game where you need all the extra 3D management, you can omit the whole giant &lt;code&gt;game1.cs&lt;/code&gt; class and instead use this nice, compact, easy, startup file.&lt;/p&gt;
    
    </summary>
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/categories/SadConsole/"/>
    
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/tags/SadConsole/"/>
    
  </entry>
  
  <entry>
    <title>Version 3 Release</title>
    <link href="http://www.sadconsole.com/2016/07/13/version-3-release/"/>
    <id>http://www.sadconsole.com/2016/07/13/version-3-release/</id>
    <published>2016-07-13T22:42:42.000Z</published>
    <updated>2016-07-14T02:07:04.890Z</updated>
    
    <content type="html"><![CDATA[<p>It’s finally done! Version 3 of SadConsole brings a lot of structural changes and increases flexibility.  <a href="/2016/04/23/thoughts-on-rendering-a-console">Previously</a> it was hard to implement new types of objects that hooked into the rendering system. And whenever I did create something extra, I always felt like I was trying to fit it around the system instead of the system being flexible enough to handle it. Not any more!</p><p>Version 3.0 has taken me 2 1/2 months, 113 commits to the code repository, and 192 files were edited.</p><p>Here is a class diagram of how the system is put together now. Click below after the picture for more about the changes.</p><img src="/2016/07/13/version-3-release/v3-rendering-classes.png" title="version 3 class structure"><a id="more"></a><p>The system is made up of three concepts (that work out to different types)</p><ol><li><p><em>TextSurface</em><br>This represents the text data of a surface.</p></li><li><p><em>TextSurfaceRenderer</em><br>Takes in TextSurface data and draws it to the screen.</p></li><li><p><em>SurfaceEditor</em><br>Provides a way to change a TextSurface, like the background or foreground of cells.</p></li></ol><p>What about the classic <strong>SadConsole.Consoles.Console</strong> type? It’s there. This class is a <code>SurfaceEditor</code> that has both a <code>TextSurface</code> and <code>TextSurfaceRenderer</code>. The concept of a <code>Console</code> comes together when you combine those three elements. The <code>Console</code> still has all the other things: cursor, position, and input handling.</p><p>You can easily use a <code>TextSurfaceRenderer</code> to render a <code>TextSurface</code> directly, and you can use the <code>SurfaceEditor</code> to change the data on the <code>TextSurface</code>, all without the actual <code>Console</code> type.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> surface = <span class="keyword">new</span> SadConsole.Consoles.TextSurface(<span class="number">16</span>, <span class="number">5</span>, SadConsole.Engine.DefaultFont);</span><br><span class="line"><span class="keyword">var</span> editor = <span class="keyword">new</span> SadConsole.Consoles.SurfaceEditor(surface);</span><br><span class="line"><span class="keyword">var</span> renderer = <span class="keyword">new</span> SadConsole.Consoles.TextSurfaceRenderer();</span><br><span class="line"></span><br><span class="line">editor.Fill(Color.Aqua, Color.Gray, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">editor.Print(<span class="number">2</span>, <span class="number">2</span>, <span class="string">"Hello World!"</span>);</span><br><span class="line"></span><br><span class="line">renderer.Render(surface, <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>This flexability allows us to create new types of data and rendering systems. For example, there is now a <code>CachedTextSurfaceRenderer</code> that instead of rendering the <code>TextSurface</code> on every render call, it renders once and keeps that output for every subsequent render call. You have to explicitly tell it to update itself. This is handy for UI elements, frames and borders, and text areas that never change once rendered. If a text surface is 10x10, that is about 200 renders calls every frame. With the <code>CachedTextSurfaceRenderer</code> you take those 200 render calls once, and then every time after that a single render call is done. Very optimized.</p><h2 id="sample-code"><a class="markdownIt-Anchor" href="#sample-code"></a> Sample code</h2><p>Here are some common examples of using the new types.</p><h3 id="create-a-console"><a class="markdownIt-Anchor" href="#create-a-console"></a> Create a console</h3><p>By default, SadConsole handles all rendering and updates of a <code>Console</code> type for you. Just add it to the <code>SadConsole.Engine.ConsoleRenderStack</code> collection.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> console = <span class="keyword">new</span> SadConsole.Consoles.Console(<span class="number">16</span>, <span class="number">5</span>);</span><br><span class="line">console.Fill(Color.Aqua, Color.Gray, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">console.Print(<span class="number">2</span>, <span class="number">2</span>, <span class="string">"Hello World!"</span>);</span><br><span class="line">console.Position = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">SadConsole.Engine.ConsoleRenderStack.Add(console);</span><br></pre></td></tr></table></figure><img src="/2016/07/13/version-3-release/hello-world-1.png" title="Hello world rendered in SadConsole"><h3 id="manually-render-a-textsurface"><a class="markdownIt-Anchor" href="#manually-render-a-textsurface"></a> Manually render a TextSurface</h3><p>You can take any existing TextSurface and render it multiple times. A console draws it self once per frame, wherever <code>Console.Position</code> points to on the screen, but we can also draw manually if we would like to duplicate the console.</p><blockquote><p><strong>NOTE</strong><br>Remember that the console is still in the <code>SadConsole.Engine.ConsoleRenderStack</code> and will draw at position <strong>1, 1</strong>.</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.Renderer.Render(console.TextSurface, <span class="keyword">new</span> Point(<span class="number">19</span>, <span class="number">1</span>), <span class="literal">false</span>);</span><br><span class="line">console.Renderer.Render(console.TextSurface, <span class="keyword">new</span> Point(<span class="number">37</span>, <span class="number">1</span>), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><img src="/2016/07/13/version-3-release/hello-world-2.png" title="Hello world rendered three times in SadConsole"><p>Instead of using the console itself to render, you could also do it all by hand.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> renderer = <span class="keyword">new</span> SadConsole.Consoles.TextSurfaceRenderer();</span><br><span class="line"><span class="keyword">var</span> textSurface = console.TextSurface;</span><br><span class="line"></span><br><span class="line">renderer.Render(textSurface, <span class="keyword">new</span> Point(<span class="number">19</span>, <span class="number">1</span>), <span class="literal">false</span>);</span><br><span class="line">renderer.Render(textSurface, <span class="keyword">new</span> Point(<span class="number">37</span>, <span class="number">1</span>), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="next"><a class="markdownIt-Anchor" href="#next"></a> Next</h2><p>In the next blog post, I’ll show how to use the render multiple layers on a console using built in types.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;It’s finally done! Version 3 of SadConsole brings a lot of structural changes and increases flexibility.  &lt;a href=&quot;/2016/04/23/thoughts-on-rendering-a-console&quot;&gt;Previously&lt;/a&gt; it was hard to implement new types of objects that hooked into the rendering system. And whenever I did create something extra, I always felt like I was trying to fit it around the system instead of the system being flexible enough to handle it. Not any more!&lt;/p&gt;
&lt;p&gt;Version 3.0 has taken me 2 1/2 months, 113 commits to the code repository, and 192 files were edited.&lt;/p&gt;
&lt;p&gt;Here is a class diagram of how the system is put together now. Click below after the picture for more about the changes.&lt;/p&gt;
&lt;img src=&quot;/2016/07/13/version-3-release/v3-rendering-classes.png&quot; title=&quot;version 3 class structure&quot;&gt;
    
    </summary>
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/categories/SadConsole/"/>
    
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/tags/SadConsole/"/>
    
  </entry>
  
  <entry>
    <title>Cached console</title>
    <link href="http://www.sadconsole.com/2016/06/01/cached-console/"/>
    <id>http://www.sadconsole.com/2016/06/01/cached-console/</id>
    <published>2016-06-02T00:45:58.000Z</published>
    <updated>2016-06-02T01:05:38.724Z</updated>
    
    <content type="html"><![CDATA[<p>Oh hai! As part of my rewrite of how SadConsole renders to the screen (<a href="https://github.com/Thraka/SadConsole/tree/sadconsole-v3" target="_blank" rel="noopener">my v3 branch</a>) I came up with a few new console types. Well… not really a new console, but it’s actually a new renderer. The class is <a href="https://github.com/Thraka/SadConsole/blob/sadconsole-v3/SadConsole.Core/Consoles/CachedTextSurfaceRenderer.cs" target="_blank" rel="noopener">SadConsole.Consoles.CachedTextSurfaceRenderer</a> (name subject to change) and it works by rendering the text data to a texture instead of the screen. Then when the renderer is drawn, it draws the texture instead of console cell data.</p><a id="more"></a><p>The normal renderer (<a href="https://github.com/Thraka/SadConsole/blob/sadconsole-v3/SadConsole.Core/Consoles/TextSurfaceRenderer.cs" target="_blank" rel="noopener">TextSurfaceRenderer</a>) crawls through every cell that is supposed to be rendered and</p><ol><li>Render a background fill for the whole rendered area</li><li>(on each cell) Render the background (if needed)</li><li>(on each cell) Render the character on top of that background (if needed)</li><li>Render a tint to the whole rendered area (if needed)</li></ol><p>If you have a console that is displaying 80x25 (standard MS-DOS text screen) it is rendering: <em>2,000 background + 2,000 character + 1 fill + 1 tint = 4,002 sprite draw calls</em>. That is a lot of drawing. Of course, the renderer is smart enough to optimize out transparent colors and backgrounds that match the default background fill color. So you may not always be doing 4,002 draw calls. Here is a console rendering 4,001 draw calls (no tint)</p><img src="/2016/06/01/cached-console/normal-renderer.png" title="normal console renderer"><p>As you can see it is running at (it’s in debug mode, so it’s slower than normal) <strong>~1000</strong> frames per second. No problem really. However, if the console we’re drawing isn’t changing at all, we’re really wasting time drawing each cell over and over. Here is that same console rendered to the <code>CachedTextSurfaceRenderer</code> renderer. (darker color here just so we know we’re in cached mode, it’s not normally darker)</p><img src="/2016/06/01/cached-console/cached-renderer.png" title="cached console renderer"><p>Much better performance. We’re only doing a single draw call too.</p><p>This renderer will be great for UI and static backgrounds, or anything that doesn’t change often. You can easily update the cached renderer with the latest state of the console data.</p><p>I’ll have some other renderers and text surface types coming soon too.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Oh hai! As part of my rewrite of how SadConsole renders to the screen (&lt;a href=&quot;https://github.com/Thraka/SadConsole/tree/sadconsole-v3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;my v3 branch&lt;/a&gt;) I came up with a few new console types. Well… not really a new console, but it’s actually a new renderer. The class is &lt;a href=&quot;https://github.com/Thraka/SadConsole/blob/sadconsole-v3/SadConsole.Core/Consoles/CachedTextSurfaceRenderer.cs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SadConsole.Consoles.CachedTextSurfaceRenderer&lt;/a&gt; (name subject to change) and it works by rendering the text data to a texture instead of the screen. Then when the renderer is drawn, it draws the texture instead of console cell data.&lt;/p&gt;
    
    </summary>
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/categories/SadConsole/"/>
    
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/tags/SadConsole/"/>
    
      <category term="Renderer" scheme="http://www.sadconsole.com/tags/Renderer/"/>
    
  </entry>
  
  <entry>
    <title>Thoughts on rendering a console</title>
    <link href="http://www.sadconsole.com/2016/04/23/thoughts-on-rendering-a-console/"/>
    <id>http://www.sadconsole.com/2016/04/23/thoughts-on-rendering-a-console/</id>
    <published>2016-04-24T00:46:02.000Z</published>
    <updated>2016-08-13T07:21:24.800Z</updated>
    
    <content type="html"><![CDATA[<p>The more and more that I use <strong>SadConsole</strong> on my own little games, the more I grow to dislike the way I render to the screen. Now, I don’t mean specifically the rendering code itself. It’s pretty good, though I have an improvement coming soon. What I mean is the way you, say from a console, get your data rendered to the screen.</p><p>A console generally has two roles, it either reads input from the user (providing visual feedback) and/or it presents characters to the user. However, the capabilities you want in drawing characters to the screen may vary. You may:</p><ul><li>Use a standard Width x Height console.</li><li>Use a bigger console and allow scrolling.</li><li>Use a single console the entire time.</li><li>Use many different consoles positioned on the screen.</li><li>A console that has multiple layers.</li><li>A console with a bunch of extra metadata.</li><li>A console for UI controls.</li><li>A floating window console.</li><li>An animated console (entity).</li></ul><p>I think that is all the types provided by <strong>SadConsole</strong>. Here is a diagram of (out of all the libraries for SadConsole) the way the classes are structured.</p><img src="/2016/04/23/thoughts-on-rendering-a-console/cellsrenderer-class.png" title="animated static ascii"><a id="more"></a><p>The <code>CellsRenderer</code> type is what actually does the drawing to the screen. All the other classes that inherit it (or inherit from <code>Console</code>) are really specialty classes that are about how a console operates.</p><table><thead><tr><th>Type</th><th>Behavior</th></tr></thead><tbody><tr><td>CellsRenderer</td><td>Handles drawing data to the screen.<br>Manages viewport and scrolling.<br>Manages cell effects.</td></tr><tr><td>Console</td><td>Implements input keyboard handling.<br>Provides a cursor for input.<br></td></tr><tr><td>LayeredConsole</td><td>Inherits from Console.<br>Provides layering.</td></tr><tr><td>ControlsConsole</td><td>Inherits from Console.<br>Supports rendering UI controls.</td></tr><tr><td>Window</td><td>Inherits from ControlsConsole, Console.<br>A bordered, title, movable console.<br>Modal or non-modal.</td></tr><tr><td>GameConsole</td><td>Inherits from LayeredConsole.<br>Adds a metadata system to attach data to cells.</td></tr><tr><td>Entity</td><td>Standalone console supporting animation.</td></tr></tbody></table><h2 id="why-this-is-bad"><a class="markdownIt-Anchor" href="#why-this-is-bad"></a> Why this is bad</h2><p>Now where things get messy is in cases like the <strong>Entity</strong> or a <strong>Window</strong> type. These console types shouldn’t support scrolling. You don’t make an entity that is bigger than the screen and only render a subset of it at a time. The same for a window. A window is meant to be totally visible on the screen. (the UI system supports hooking up scroll bars and things)</p><p>So what happens to an entity when you adjust the viewport to only render a subset of the cells? Nothing bad mind you, but you may not get what you expected. Especially when the entity is animating and flipping through multiple cell surfaces that have completely different sets of cells.</p><p>The problem is that the <strong>CellsRenderer</strong> type supports all these rendering systems out of the box, it’s a jack-of-all-trades. Which is great for flexibility, but it puts a strain on the developer to deeply understand the behavior of the types and not mess something up.</p><h3 id="the-entity"><a class="markdownIt-Anchor" href="#the-entity"></a> The entity</h3><p>The way the entity works is it uses an animation type. The animation is a bunch of frames (CellData classes) and each frame is presented as the <em>current frame</em> during rendering. If the <em>current frame</em> hasn’t changed, the <strong>CellsRenderer</strong> doesn’t check for which cells to render, it already has them cached.</p><h3 id="back-to-the-problem"><a class="markdownIt-Anchor" href="#back-to-the-problem"></a> Back to the problem</h3><p>Now I ran into a situation where even myself, the one most familiar with the code, was confused as to why my entity wasn’t rendering correctly. What I had done is resized the animation of an entity, which just resizes the CellData of all the animation’s frames. The <em>current frame</em> class reference hadn’t changed, but the size of the frame did. So when the <strong>CellsRenderer</strong> went to render the old 1x1 console, it only drew the top-left cell even though the CellsSurface was much bigger. Ouch. The fix was just to force a recalculation after I resized the animation.</p><p>Now with an entity, all this viewport rect rendering stuff doesn’t matter. So the system that is in place for other consoles was stepping on the simpler entity rendering.</p><p>Well, I want this library to be easy to work with, so I think I need to separate out functionality out either into components, or specialized consoles. And then for when rendering systems must be different, specialized rendering. I’m not sure what it will look like, but I want to make sure it is easier for others to work with.</p><p>There are some awesome .NET console game libraries (like <a href="https://bitbucket.org/clarktravism/rlnet/" target="_blank" rel="noopener">RLNET</a> and <a href="https://github.com/derrickcreamer/SunshineConsole" target="_blank" rel="noopener">SunShine Console</a>) out there much like mine that are quick and easy to use. That is something I want for SadConsole. I think I’ve gotten part of the way there though with NuGet. But more can be done…</p><p>… Stay tuned …</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The more and more that I use &lt;strong&gt;SadConsole&lt;/strong&gt; on my own little games, the more I grow to dislike the way I render to the screen. Now, I don’t mean specifically the rendering code itself. It’s pretty good, though I have an improvement coming soon. What I mean is the way you, say from a console, get your data rendered to the screen.&lt;/p&gt;
&lt;p&gt;A console generally has two roles, it either reads input from the user (providing visual feedback) and/or it presents characters to the user. However, the capabilities you want in drawing characters to the screen may vary. You may:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use a standard Width x Height console.&lt;/li&gt;
&lt;li&gt;Use a bigger console and allow scrolling.&lt;/li&gt;
&lt;li&gt;Use a single console the entire time.&lt;/li&gt;
&lt;li&gt;Use many different consoles positioned on the screen.&lt;/li&gt;
&lt;li&gt;A console that has multiple layers.&lt;/li&gt;
&lt;li&gt;A console with a bunch of extra metadata.&lt;/li&gt;
&lt;li&gt;A console for UI controls.&lt;/li&gt;
&lt;li&gt;A floating window console.&lt;/li&gt;
&lt;li&gt;An animated console (entity).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I think that is all the types provided by &lt;strong&gt;SadConsole&lt;/strong&gt;. Here is a diagram of (out of all the libraries for SadConsole) the way the classes are structured.&lt;/p&gt;
&lt;img src=&quot;/2016/04/23/thoughts-on-rendering-a-console/cellsrenderer-class.png&quot; title=&quot;animated static ascii&quot;&gt;
    
    </summary>
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/categories/SadConsole/"/>
    
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/tags/SadConsole/"/>
    
  </entry>
  
  <entry>
    <title>Entity animation bug</title>
    <link href="http://www.sadconsole.com/2016/04/21/entity-animation-bug/"/>
    <id>http://www.sadconsole.com/2016/04/21/entity-animation-bug/</id>
    <published>2016-04-21T15:10:44.000Z</published>
    <updated>2016-08-13T07:21:24.656Z</updated>
    
    <content type="html"><![CDATA[<p>Yesterday I was writing some <a href="https://github.com/Thraka/SadConsole/commit/066e68bc4ce8ae8f1a3e525e347f89e0e9f14f66#diff-2a6004b6fa04ffddd85619ce217d01a5R20" target="_blank" rel="noopener">code to generate</a> an entity that animated white static, like you have on an old TV.</p><img src="/2016/04/21/entity-animation-bug/static.gif" title="animated static ascii"><p>And I found a bug…</p><p>The bug has to do with when you create an entity and then add a new animation to it that replaces the <strong>default</strong> animation. The entity has the new animation but the <code>Entity.CurrentAnimation</code> property still points to the old one. Not good.</p><p>Fixed now in version 2.7+.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Yesterday I was writing some &lt;a href=&quot;https://github.com/Thraka/SadConsole/commit/066e68bc4ce8ae8f1a3e525e347f89e0e9f14f66#diff-2a6004b6f
      
    
    </summary>
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/categories/SadConsole/"/>
    
    
      <category term="SadConsole" scheme="http://www.sadconsole.com/tags/SadConsole/"/>
    
      <category term="Bug" scheme="http://www.sadconsole.com/tags/Bug/"/>
    
  </entry>
  
</feed>
