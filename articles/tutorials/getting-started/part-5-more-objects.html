<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Get Started Part 5 - Object handling | SadConsole v10 </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Get Started Part 5 - Object handling | SadConsole v10 ">
      
      <meta name="description" content="This article explores creating more objects to put on the game map. The objects have code that reacts to the player touching them. Part 5 of the SadConsole getting started series.">
      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/SadConsoleLogo.gif" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="get-started-5---more-objects">Get Started 5 - More objects</h1>

<p>In this part of the tutorial you learn how to add different types of map objects that can react differently to the player touching them.</p>
<p>Previous articles in this tutorial:</p>
<ul>
<li><a href="part-2-cursor-parents.html">Get Started 2 - Cursors and parenting</a></li>
<li><a href="part-3-input.html">Get Started 3 - Input</a></li>
<li><a href="part-4-mapobject.html">Get Started 4 - A proper map</a></li>
</ul>
<h2 id="prerequisites">Prerequisites</h2>
<p>This part of the tutorial continues where the previous one left off. If you don't have your code handy, you can download it from <a href="projects/Part4.zip">here</a> and follow along.</p>
<h2 id="concrete-types">Concrete types</h2>
<p>The <code>GameObject</code> type represents a thing that can be positioned and drawn on the map. However, it doesn't really &quot;do&quot; anything. Let's create two new classes, one for <strong>monster</strong> and one for <strong>treasure</strong>. Both will inherit from <code>GameObject</code> and override the <code>Touched</code> method.</p>
<h3 id="treasure">Treasure</h3>
<p>To create the treasure class, perform the following:</p>
<ol>
<li><p>Add a new class to the project, named <em>Treasure.cs</em>.</p>
</li>
<li><p>Open the code file and replace the code with the following snippet:</p>
<pre><code class="lang-csharp">namespace SadConsoleGame;

internal class Treasure: GameObject
{

}
</code></pre>
</li>
<li><p>In the class declaration, add a new constructor that calls the base class's constructor. This sets the appearance of the &quot;monster&quot; object.</p>
<pre><code class="lang-csharp">public Treasure(Point position, IScreenSurface hostingSurface)
    : base(new ColoredGlyph(Color.Yellow, Color.Black, 'v'), position, hostingSurface)
{

}
</code></pre>
<p>Unlike instantiating a normal <code>GameObject</code> type, where you must specify how the game object looks, <code>Treasure</code> always looks like &quot;treasure&quot; in the game. This is because the constructor for <code>Treasure</code> specifies the <code>ColoredGlyph</code> used by the game object. Any other defaults (though they aren't any yet) could be specified in the constructor.</p>
</li>
<li><p>Next, add the code for the <code>Touched</code> method. Note that the <code>map.RemoveMapObject</code> method doesn't yet exist.</p>
<pre><code class="lang-csharp">public override bool Touched(GameObject source, Map map)
{
    // Is the player the one that touched us?
    if (source == map.UserControlledObject)
    {
        map.RemoveMapObject(this);
        return true;
    }

    return false;
}
</code></pre>
<p>The previous code checks if the player, the <code>UserControlledObject</code> is the one that touched this treasure. If it was, the object is removed from the map and <code>true</code> is returned, which lets the player move into that space.</p>
</li>
</ol>
<p>Treasure is finished, but the <code>RemoveMapObject</code> method on the map doesn't exist, we'll create that after the <code>Monster</code> type is created.</p>
<h3 id="monster">Monster</h3>
<p>To create the monster class, perform the following:</p>
<ol>
<li><p>Add a new class to the project, named <em>Monster.cs</em>.</p>
</li>
<li><p>Open the code file and replace the code with the following snippet:</p>
<pre><code class="lang-csharp">namespace SadConsoleGame;

internal class Monster : GameObject
{

}
</code></pre>
</li>
<li><p>In the class declaration, add a new constructor that calls the base class's constructor.</p>
<pre><code class="lang-csharp">public Monster(Point position, IScreenSurface hostingSurface)
    : base(new ColoredGlyph(Color.Red, Color.Black, 'M'), position, hostingSurface)
{

}
</code></pre>
<p>Just like <code>Treasure</code>, <code>Monster</code> specifies the <code>ColoredGlyph</code> for every <code>Monster</code> type. You can introduce variation later, but for now, they'll all be <code>M</code> on the screen.</p>
</li>
<li><p>Next, add the code for the <code>Touched</code> method.</p>
<pre><code class="lang-csharp">public override bool Touched(GameObject source, Map map)
{
    return base.Touched(source, map);
}
</code></pre>
</li>
</ol>
<h2 id="update-the-map-with-removemapobject">Update the map with RemoveMapObject</h2>
<p>The map needs to expose the ability to remove an object from itself. This will be the <code>RemoveMapObject</code> method.</p>
<ol>
<li><p>Open the <em>Map.cs</em> file.</p>
</li>
<li><p>Add the following code:</p>
<pre><code class="lang-csharp">public void RemoveMapObject(GameObject mapObject)
{
    if (_mapObjects.Contains(mapObject))
    {
        _mapObjects.Remove(mapObject);
        mapObject.RestoreMap(this);
    }
}
</code></pre>
</li>
</ol>
<p>This code checks if the game object is actually associated with the map, and if it is, removes it from the map. There is another method used here though, <code>mapObject.RestoreMap</code>. When a game object is moved, it restores the map space before drawing itself to the new map space. We need to expose that capability so that when a game object is removed from the map, it can restore the map's space.</p>
<h2 id="update-the-game-object-with-restoremap">Update the game object with RestoreMap</h2>
<p>Next, add the <code>RestoreMap</code> method to the <code>GameObject</code> class. This lets external objects, such as the map, tell the game object to fill back in the old map space.</p>
<ol>
<li><p>Open the <em>GameObject.cs</em> file.</p>
</li>
<li><p>Add the following code:</p>
<pre><code class="lang-csharp">public void RestoreMap(Map map) =&gt;
    _mapAppearance.CopyAppearanceTo(map.SurfaceObject.Surface[Position]);
</code></pre>
<p>This code uses another modern C# technique, the <code>=&gt;</code> expression operator. When you declare a method and only have a single code statement, you can omit the <code>{ }</code> block and use the expression operator to infer the single code statement as the body of the method.</p>
</li>
</ol>
<h2 id="use-the-new-treasure-and-monster-classes">Use the new treasure and monster classes</h2>
<p>The map has the <code>CreateTreasure</code> and <code>CreateMonster</code> methods, but they currently use the<code>GameObject</code> class. These two methods need to be modified to use the concrete types.</p>
<ol>
<li><p>Open the <em>Map.cs</em> file.</p>
</li>
<li><p>Change the code in the <code>CreateTreasure</code> method. Alter the type used when creating the treasure instance:</p>
<p>From:</p>
<pre><code class="lang-csharp">GameObject treasure = new GameObject(new ColoredGlyph(Color.Yellow, Color.Black, 'v'), randomPosition, _mapSurface);
</code></pre>
<p>To:</p>
<pre><code class="lang-csharp">Treasure treasure = new Treasure(randomPosition, _mapSurface);
</code></pre>
<p>Note that the constructor parameters changed. The <code>Treaasure</code> type doesn't require a <code>ColoredGlyph</code> to describe how it looks.</p>
</li>
<li><p>Next, change the code in the <code>CreateMonster</code> method in the same way as <code>CreateTreasure</code>:</p>
<p>From:</p>
<pre><code class="lang-csharp">GameObject monster = new GameObject(new ColoredGlyph(Color.Red, Color.Black, 'M'), randomPosition, _mapSurface);
</code></pre>
<p>To:</p>
<pre><code class="lang-csharp">Monster monster = new Monster(randomPosition, _mapSurface);
</code></pre>
</li>
</ol>
<h2 id="run-the-game">Run the game</h2>
<p>Before you run the game to test out touching the treasure and monster, let's add more monsters and treasure to the map. The map has two methods, <code>CreateTreasure</code> and <code>CreateMonster</code>, which are both called once in the map's constructor. Let's call it five times instead, which makes the map a little more populated.</p>
<ol>
<li><p>Open the <em>Map.cs</em> file.</p>
</li>
<li><p>Find the <code>Map</code> constructor and add a <code>for</code> loop that runs five times.</p>
<pre><code class="lang-csharp">public Map(int mapWidth, int mapHeight)
{
    _mapObjects = new List&lt;GameObject&gt;();
    _mapSurface = new ScreenSurface(mapWidth, mapHeight);
    _mapSurface.UseMouse = false;

    FillBackground();

    UserControlledObject = new GameObject(new ColoredGlyph(Color.White, Color.Black, 2), _mapSurface.Surface.Area.Center, _mapSurface);

    for (int i = 0; i &lt; 5; i++)
    {
        CreateTreasure();
        CreateMonster();
    }
}
</code></pre>
</li>
<li><p>Run the game.</p>
</li>
</ol>
<p>Now you'll see that there are multiple treasure objects. Walk the player into them and notice that they disappear. Do the same with monsters and notice that they remain.</p>
<p><img src="images/part-5-more-objects/treasure_pickup.gif" alt="Player moving around and picking up treasure."></p>
<h2 id="conclusion">Conclusion</h2>
<p>As you can see, the game is starting to come together, there are game objects and a map object that ties everything together. In the next part of the series, you'll explore how to add more consoles to the screen to present status and information to the player.</p>
<ul>
<li>Next: Get Started 6 - .... Not yet ready</li>
<li><a href="projects/Part5.zip">Download the code for this part of the tutorial</a></li>
</ul>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
