<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>title: What are Screens, Consoles, and Surfaces?
layout: docpage
comments: false
searcharchive: true </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="title: What are Screens, Consoles, and Surfaces?
layout: docpage
comments: false
searcharchive: true ">
    <meta name="generator" content="docfx 2.40.11.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/dracula.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" src="../../images/SadConsoleLogo.gif" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h2 id="title-what-are-screens-consoles-and-surfaceslayout-docpagecomments-falsesearcharchive-true">title: What are Screens, Consoles, and Surfaces?
layout: docpage
comments: false
searcharchive: true</h2>

<blockquote>
<p><strong>NOTE</strong><br>
This article was written for version 7 of SadConsole.</p>
</blockquote>
<p>The main type of object in SadConsole is the <code>ScreenObject</code>. As you can probably guess from the name, it represents something that can be displayed on the screen. Alone, screen objects do not really do much of anything, they are empty shells that form the base of objects.</p>
<p>SadConsole has two main functions that are performed on screen objects as the game loop runs:</p>
<ol>
<li>Update SadConsole objects.</li>
<li>Draw SadConsole objects.</li>
</ol>
<p>Intermixed in that process are all sorts of other things, input management, texture caching for performance, screen position calculations, etc.</p>
<p>SadConsole uses the <code>ScreenObject</code> as the base class for all other objects, such as: consoles, drawing surfaces, and game entities. All of the following objects inherit from <code>ScreenObject</code> and can be positioned and parented to any other <code>ScreenObject</code> type.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Console related</strong></td>
<td></td>
</tr>
<tr>
<td>SadConsole.Console</td>
<td>Keyboard, mouse, virtual cursor support.</td>
</tr>
<tr>
<td>SadConsole.ControlsConsole</td>
<td>Same as Console. Adds text UI framework.</td>
</tr>
<tr>
<td>SadConsole.Window</td>
<td>Same as ControlsConsole. Adds floating/movable dialog system.</td>
</tr>
<tr>
<td>SadConsole.ConsoleContainer</td>
<td>A fake console that does nothing. It can receive keyboard and mouse events. Exists for you to extend and wrap objects that cannot take keyboard/mouse input.</td>
</tr>
<tr>
<td><strong>Surface related</strong></td>
<td></td>
</tr>
<tr>
<td>SadConsole.Surfaces.SurfaceBase</td>
<td>Abstract base class that defines an array of SadConsole.Cell objects. Provides methods to print and draw on the surface.</td>
</tr>
<tr>
<td>SadConsole.Surfaces.Basic</td>
<td>Basic implementation of SurfaceBase. Does nothing extra.</td>
</tr>
<tr>
<td>SadConsole.Surfaces.BasicNoDraw</td>
<td>Just like the Basic class but does not use a cached texture and will not draw itself on the screen, ever.</td>
</tr>
<tr>
<td>SadConsole.Surfaces.Animated</td>
<td>Animated surface that has multiple BasicNoDraw frames.</td>
</tr>
<tr>
<td>SadConsole.Surfaces.Layered</td>
<td>Multiple Basic surfaces that are drawn on top of each other to form a layered surface.</td>
</tr>
<tr>
<td><strong>Entity related</strong></td>
<td></td>
</tr>
<tr>
<td>SadConsole.Entities.Entity</td>
<td>Contains multiple animations. Has an additional position offset for syncing with viewports.</td>
</tr>
<tr>
<td>SadConsole.Entities.Zone</td>
<td>An invisible rectangle. Has a settings dictionary. Use with a game map to mark regions.</td>
</tr>
<tr>
<td>SadConsole.Entities.Hotspot</td>
<td>One or more invisible points. Has a settings dictionary. Use with a game map to mark specific spots.</td>
</tr>
<tr>
<td>SadConsole.Entities.EntityManager</td>
<td>Contains entities, zones, and hotspots. When parented to a SurfaceBase, manages offset syncing for objects.</td>
</tr>
</tbody>
</table>
<h2 id="screenobject-processing">ScreenObject processing</h2>
<p>SadConsole uses the <code>SadConsole.Global.CurrentScreen</code> property to determine what objects are going to be processed. The current screen starts out as a <code>ScreenObject</code>, which has nothing to render. If you add something to its <code>Children</code> collection, those objects will be processed. They may or may not be drawn depending on the type of object.</p>
<p>In general, <code>ScreenObject</code> types handle the following:</p>
<ol>
<li>Position</li>
<li>Visibility toggle</li>
<li>Update and Drawing hooks</li>
<li>Parent-child relationship with other ScreenObjects</li>
</ol>
<p>When SadConsole starts, the current screen is initialized like so:</p>
<pre><code class="lang-csharp">Global.CurrentScreen = new ScreenObject();
</code></pre>
<p>From that point, you can add what you want to the current screen to get it in the system. For example, this code would add a new console (a console is a type of <code>ScreenObject</code>) to the engine:</p>
<pre><code class="lang-csharp">SadConsole.Global.CurrentScreen = new ScreenObject();

var console1 = new SadConsole.Console(10, 4);
console1.Fill(Color.DarkBlue, Color.LightGray, 0);
console1.Print(1, 1, &quot;Hello!&quot;);
console1.Position = new Point(3, 3);

SadConsole.Global.CurrentScreen.Children.Add(console1);
</code></pre>
<p><img src="images/screen-example-1.png" alt=""></p>
<p>Or this code would add two different consoles to the system, and position them at different points:</p>
<pre><code class="lang-csharp">var console1 = new SadConsole.Console(10, 4);
console1.Fill(Color.DarkBlue, Color.LightGray, 0);
console1.Print(1, 1, &quot;Hello!&quot;);
console1.Position = new Point(3, 3);

var console2 = new SadConsole.Console(10, 4);
console2.Fill(Color.LightGray, Color.DarkBlue, 0);
console2.Print(1, 1, &quot;Hello!&quot;);
console2.Position = new Point(20, 10);

SadConsole.Global.CurrentScreen.Children.Add(console1);
SadConsole.Global.CurrentScreen.Children.Add(console2);
</code></pre>
<p><img src="images/screen-example-2.png" alt=""></p>
<p>At this point, the object hierarchy in current screen looks like the following:</p>
<pre><code class="lang-text">Global.CurrentScreen
|
\-- console1
\-- console2
</code></pre>
<p>If we were to parent <code>console2</code> to <code>console1</code>, it would look like the following:</p>
<pre><code class="lang-csharp">console1.Children.Add(console2);
Global.CurrentScreen.Children.Add(console1);
</code></pre>
<pre><code class="lang-text">Global.CurrentScreen
|
\-- console1
    |
    \-- console2
</code></pre>
<p><img src="images/screen-example-3.png" alt=""></p>
<p>If you compare this screenshot with the previous, you'll notice that <code>console2</code> is positioned in a slightly different place. That is because the position of where something is drawn is based on its parent. Here are the position settings with both consoles added directly to the current screen:</p>
<pre><code class="lang-text">Global.CurrentScreen [Pos: (0,0) Drawn: (0,0)]
|
\-- console1 [Pos: (3,3) Drawn: (3,3)]
\-- console2 [Pos: (20,10) Drawn: (20,10)]
</code></pre>
<p>When the parent of <code>console2</code> was changed from the <code>CurrentScreen</code> to <code>console1</code>, its drawing position was changed:</p>
<pre><code class="lang-text">Global.CurrentScreen [Pos: (0,0) Drawn: (0,0)]
|
\-- console1 [Pos: (3,3) Drawn: (3,3)]
    |
    \-- console2 [Pos: (20,10) Drawn: (23,13)]
</code></pre>
<p>What happened is that <code>console2</code> inherted the drawing position of its parent, <code>console1</code> <strong>(3,3)</strong>, and was offset by that amount. So while the position of <code>console2</code> was still set to <strong>(20,10)</strong> the final drawing position was calculated by <code>object_Position (20,10) + parent_Render_Position (3,3) = object_Render_Position (23,13)</code>.</p>
<p>As SadConsole processes an object, if it finds that <code>IsVisible</code> value is set to false, it immediately stops processing that object (for drawing) and does not inspect the <code>Children</code> of that object. So, if you were to hide <code>console1</code> with <code>console1.IsVisible = false</code> then <code>console2</code> would not be drawn.</p>
<h2 id="surfaces-and-consoles">Surfaces and Consoles</h2>
<p>The <code>SadConsole.Surfaces.SurfaceBase</code> is made up of <code>SadConsole.Cell</code> objects. A <code>Cell</code> is a glyph with a foreground and background color. The surface provides methods for writing text on a surface. Other methods such as shifting the entire surface in a direction, setting the background color of a single cell, or drawing a box shape, are provided. The base class for a surface is <code>ScreenObject</code>, so it can be positioned on the screen just like a <code>Console</code> can.</p>
<p>The <code>SadConsole.Surfaces.SurfaceBase</code> type is an abstract base class used by other objects. The ``SadConsole.Surfaces.Basic` surface is an implementation of that base class with no extra capabilities.</p>
<p>A <code>SadConsole.Console</code> type is actually a <code>SadConsole.Surfaces.SurfaceBase</code> with a bunch of extra handlers attached to it so you can use it like a terminal. It is not exactly meant to emulate a complete terminal, but it has some similar capabilities. Since the console is a surface, it has all of the same functions a surface does, such as printing text or manipulating individual cells. The console also provides keyboard and mouse input processing. It provides a <code>Cursor</code> object that emulates a terminal cursor. You can position the cursor within the console and use it for keyboard input or programmatically print with it.</p>
<p>Since both the console and surface are <code>ScreenObject</code> types, a surface can be parented to the <code>CurrentScreen</code>, to a console, or to any other <code>ScreenObject</code>. Our code from above that created two consoles can easily be replaced with a <code>Basic</code> surface:</p>
<pre><code class="lang-csharp">var surface1 = new SadConsole.Surfaces.Basic(10, 4);
surface1.Fill(Color.DarkBlue, Color.LightGray, 0);
surface1.Print(1, 1, &quot;Hello!&quot;);
surface1.Position = new Point(3, 3);

var surface2 = new SadConsole.Surfaces.Basic(10, 4);
surface2.Fill(Color.LightGray, Color.DarkBlue, 0);
surface2.Print(1, 1, &quot;Hello!&quot;);
surface2.Position = new Point(20, 10);

SadConsole.Global.CurrentScreen.Children.Add(surface1);
SadConsole.Global.CurrentScreen.Children.Add(surface2);
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
